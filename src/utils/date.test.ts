/**
 * date.ts - テストスイート
 *
 * 関連要件:
 * - REQ-001: frontmatterでpubDate, updatedDateを管理
 * - REQ-102: 記事一覧で公開日を表示
 * - REQ-112: 記事詳細で公開日・更新日を表示
 * - NFR-001: Lighthouse 90+点維持（外部ライブラリ不使用）
 *
 * 関連文書:
 * - テストケース定義書: docs/implements/blog-article-management/TASK-0006/date-utils-testcases.md
 * - 要件定義書: docs/implements/blog-article-management/TASK-0006/date-utils-requirements.md
 * - タスクノート: docs/implements/blog-article-management/TASK-0006/note.md
 * - テストパターン: docs/design/frontend-test-infra/test-patterns.md
 */

import { afterEach, describe, expect, it, vi } from 'vitest';
import { formatDate, getRelativeTime } from './date';

describe('date utilities', () => {
  // ========================================
  // セットアップ・クリーンアップ
  // ========================================

  afterEach(() => {
    // 【テスト後処理】: Fake Timersを元に戻す
    // 【状態復元】: 次のテストに影響しないよう実時間に復元
    vi.useRealTimers();
  });

  // ========================================
  // formatDate() テストケース
  // ========================================

  describe('formatDate', () => {
    // ========================================
    // 正常系テストケース
    // ========================================

    describe('正常系テストケース', () => {
      // TC-D-001: 日本語フォーマットでの日付表示 🔵
      it('TC-D-001: 日本語フォーマットで日付を表示する', () => {
        // 【テスト目的】: formatDate()が日本語フォーマットで正しく日付を出力することを確認
        // 【テスト内容】: 標準的なDateオブジェクトを渡し、「YYYY年M月D日」形式で返されるか検証
        // 【期待される動作】: Intl.DateTimeFormatを使用して日本語ロケールで正しくフォーマット
        // 🔵 信頼性: test-patterns.mdのサンプル実装より

        // 【テストデータ準備】: 標準的な日付（2025年1月15日）を用意
        // 【前提条件確認】: Dateオブジェクトが有効であること
        const date = new Date('2025-01-15T10:30:00Z');

        // 【実際の処理実行】: formatDate関数を呼び出し
        // 【処理内容】: DateオブジェクトをIntl.DateTimeFormatで日本語フォーマットに変換
        const result = formatDate(date);

        // 【結果検証】: 日本語フォーマットで出力されることを確認
        // 【期待値確認】: 「2025年1月15日」形式で返されること
        // 【品質保証】: 日付表示の基本機能が正しく動作すること
        // 🔵 信頼性: test-patterns.mdより
        expect(result).toBe('2025年1月15日'); // 【確認内容】: 日本語フォーマットでの出力
      });

      // TC-D-002: 2桁月（12月）の表示 🔵
      it('TC-D-002: 2桁月（12月）を正しく表示する', () => {
        // 【テスト目的】: 2桁月（12月）が正しくフォーマットされることを確認
        // 【テスト内容】: 12月の日付を渡し、「12月」と正しく表示されるか検証
        // 【期待される動作】: 月の桁数に関わらず正しくフォーマット
        // 🔵 信頼性: 要件定義書セクション2.1より

        // 【テストデータ準備】: 12月の日付を用意
        const date = new Date('2025-12-25');

        // 【実際の処理実行】: formatDate関数を呼び出し
        const result = formatDate(date);

        // 【結果検証】: 12月が正しく表示されることを確認
        // 🔵 信頼性: 要件定義書より
        expect(result).toBe('2025年12月25日'); // 【確認内容】: 2桁月の正しい表示
      });

      // TC-D-003: 日本語ロケールでの月表記 🔵
      it('TC-D-003: 日本語ロケールで月が正しく表記される', () => {
        // 【テスト目的】: 日本語ロケールで月が漢字表記になることを確認
        // 【テスト内容】: 6月の日付を渡し、「6月」と表示されるか検証
        // 【期待される動作】: ja-JPロケールにより日本語表記
        // 🔵 信頼性: test-patterns.mdより

        // 【テストデータ準備】: 6月の日付を用意
        const date = new Date('2025-06-01');

        // 【実際の処理実行】: formatDate関数を呼び出し
        const result = formatDate(date);

        // 【結果検証】: 日本語形式で表示されることを確認
        // 【確認内容】: 「June」ではなく「6月」と表示されること
        // 🔵 信頼性: test-patterns.mdより
        expect(result).toBe('2025年6月1日'); // 【確認内容】: 日本語ロケールでの月表記
      });
    });

    // ========================================
    // 異常系テストケース
    // ========================================

    describe('異常系テストケース', () => {
      // TC-D-101: 無効な日付でエラーをスロー 🔵
      it('TC-D-101: 無効な日付でエラーをスローする', () => {
        // 【テスト目的】: 無効な日付入力時に適切なエラーがスローされることを確認
        // 【テスト内容】: Invalid Dateオブジェクトを渡し、エラーがスローされるか検証
        // 【期待される動作】: Error: Invalid dateがスローされる
        // 🔵 信頼性: test-patterns.mdのサンプル実装より

        // 【テストデータ準備】: 無効な日付文字列から生成されたDateオブジェクト
        // 【前提条件確認】: isNaN(date.getTime())がtrueになること
        const invalidDate = new Date('invalid');

        // 【実際の処理実行】: formatDate関数を呼び出し
        // 【処理内容】: 無効な日付に対してエラーをスローする処理

        // 【結果検証】: エラーがスローされることを確認
        // 【期待値確認】: 'Invalid date'メッセージを含むエラー
        // 【品質保証】: 不正入力時にシステムが安全にエラーを報告すること
        // 🔵 信頼性: test-patterns.mdより
        expect(() => formatDate(invalidDate)).toThrow('Invalid date'); // 【確認内容】: 無効な日付でエラースロー
      });

      // TC-D-102: NaN Dateでエラーをスロー 🔵
      it('TC-D-102: NaN Dateでエラーをスローする', () => {
        // 【テスト目的】: NaNから生成されたDateでエラーがスローされることを確認
        // 【テスト内容】: new Date(NaN)を渡し、エラーがスローされるか検証
        // 【期待される動作】: Error: Invalid dateがスローされる
        // 🔵 信頼性: note.mdの「無効な日付の処理」より

        // 【テストデータ準備】: NaNから生成されたDateオブジェクト
        const nanDate = new Date(Number.NaN);

        // 【結果検証】: エラーがスローされることを確認
        // 🔵 信頼性: note.mdより
        expect(() => formatDate(nanDate)).toThrow('Invalid date'); // 【確認内容】: NaN Dateでエラースロー
      });
    });

    // ========================================
    // 境界値テストケース
    // ========================================

    describe('境界値テストケース', () => {
      // TC-D-201: 年末（12月31日）の日付表示 🔵
      it('TC-D-201: 年末（12月31日）を正しく表示する', () => {
        // 【テスト目的】: 年末（12月31日）が正しくフォーマットされることを確認
        // 【テスト内容】: 年の最終日を渡し、正しく表示されるか検証
        // 【期待される動作】: 境界日付でも正常にフォーマット
        // 🔵 信頼性: 要件定義書セクション4.2より

        // 【テストデータ準備】: 年末の日付（2025年12月31日）
        // 【境界条件】: 年の最終日
        const date = new Date('2025-12-31');

        // 【実際の処理実行】: formatDate関数を呼び出し
        const result = formatDate(date);

        // 【結果検証】: 年末日付が正しく表示されることを確認
        // 🔵 信頼性: 要件定義書より
        expect(result).toBe('2025年12月31日'); // 【確認内容】: 年末の境界値処理
      });

      // TC-D-202: 年始（1月1日）の日付表示 🔵
      it('TC-D-202: 年始（1月1日）を正しく表示する', () => {
        // 【テスト目的】: 年始（1月1日）が正しくフォーマットされることを確認
        // 【テスト内容】: 年の最初の日を渡し、正しく表示されるか検証
        // 【期待される動作】: 境界日付でも正常にフォーマット
        // 🔵 信頼性: 要件定義書セクション4.2より

        // 【テストデータ準備】: 年始の日付（2026年1月1日）
        // 【境界条件】: 年の最初の日
        const date = new Date('2026-01-01');

        // 【実際の処理実行】: formatDate関数を呼び出し
        const result = formatDate(date);

        // 【結果検証】: 年始日付が正しく表示されることを確認
        // 🔵 信頼性: 要件定義書より
        expect(result).toBe('2026年1月1日'); // 【確認内容】: 年始の境界値処理
      });

      // TC-D-203: 閏年（2月29日）の日付表示 🔵
      it('TC-D-203: 閏年（2月29日）を正しく表示する', () => {
        // 【テスト目的】: 閏年の2月29日が正しくフォーマットされることを確認
        // 【テスト内容】: 閏年にのみ存在する日付を渡し、正しく表示されるか検証
        // 【期待される動作】: 特殊な日付でも正常にフォーマット
        // 🔵 信頼性: note.mdの「境界値: 閏年」より

        // 【テストデータ準備】: 閏年の2月29日（2024年）
        // 【境界条件】: 閏年にのみ存在する日付
        const date = new Date('2024-02-29');

        // 【実際の処理実行】: formatDate関数を呼び出し
        const result = formatDate(date);

        // 【結果検証】: 閏年日付が正しく表示されることを確認
        // 🔵 信頼性: note.mdより
        expect(result).toBe('2024年2月29日'); // 【確認内容】: 閏年の境界値処理
      });

      // TC-D-204: 月初（1日）の日付表示 🔵
      it('TC-D-204: 月初（1日）を正しく表示する', () => {
        // 【テスト目的】: 月初（1日）が正しくフォーマットされることを確認
        // 【テスト内容】: 月の最初の日を渡し、正しく表示されるか検証
        // 🔵 信頼性: 要件定義書より妥当な推測

        // 【テストデータ準備】: 月初の日付（3月1日）
        const date = new Date('2025-03-01');

        // 【実際の処理実行】: formatDate関数を呼び出し
        const result = formatDate(date);

        // 【結果検証】: 月初日付が正しく表示されることを確認
        // 🔵 信頼性: 要件定義書より
        expect(result).toBe('2025年3月1日'); // 【確認内容】: 月初の境界値処理
      });
    });
  });

  // ========================================
  // getRelativeTime() テストケース
  // ========================================

  describe('getRelativeTime', () => {
    // ========================================
    // 正常系テストケース
    // ========================================

    describe('正常系テストケース', () => {
      // TC-R-001: 今日の日付で「今日」を返す 🔵
      it('TC-R-001: 今日の日付で「今日」を返す', () => {
        // 【テスト目的】: 今日の日付が「今日」と表示されることを確認
        // 【テスト内容】: 現在日時を渡し、「今日」が返されるか検証
        // 【期待される動作】: 日付差分0日の場合「今日」を返す
        // 🔵 信頼性: test-patterns.mdのサンプル実装より

        // 【テスト前準備】: 現在日時を固定
        vi.useFakeTimers();
        vi.setSystemTime(new Date('2025-01-15T12:00:00.000Z'));

        // 【テストデータ準備】: 今日の日付
        const today = new Date('2025-01-15T09:00:00.000Z');

        // 【実際の処理実行】: getRelativeTime関数を呼び出し
        const result = getRelativeTime(today);

        // 【結果検証】: 「今日」が返されることを確認
        // 🔵 信頼性: test-patterns.mdより
        expect(result).toBe('今日'); // 【確認内容】: 当日は「今日」と表示

        // 【テスト後処理】: タイマーを元に戻す
        vi.useRealTimers();
      });

      // TC-R-002: 1日前の日付で「1日前」を返す 🔵
      it('TC-R-002: 1日前の日付で「1日前」を返す', () => {
        // 【テスト目的】: 1日前の日付が「1日前」と表示されることを確認
        // 【テスト内容】: 昨日の日付を渡し、「1日前」が返されるか検証
        // 【期待される動作】: 日付差分1日の場合「1日前」を返す
        // 🔵 信頼性: test-patterns.mdのサンプル実装より

        // 【テスト前準備】: 現在日時を固定
        vi.useFakeTimers();
        vi.setSystemTime(new Date('2025-01-15T12:00:00.000Z'));

        // 【テストデータ準備】: 1日前の日付
        const yesterday = new Date('2025-01-14T12:00:00.000Z');

        // 【実際の処理実行】: getRelativeTime関数を呼び出し
        const result = getRelativeTime(yesterday);

        // 【結果検証】: 「1日前」が返されることを確認
        // 🔵 信頼性: test-patterns.mdより
        expect(result).toBe('1日前'); // 【確認内容】: 1日前は「1日前」と表示

        // 【テスト後処理】: タイマーを元に戻す
        vi.useRealTimers();
      });

      // TC-R-003: N日前の日付で「N日前」を返す 🔵
      it('TC-R-003: N日前の日付で「N日前」を返す', () => {
        // 【テスト目的】: N日前の日付が「N日前」と表示されることを確認
        // 【テスト内容】: 5日前の日付を渡し、「5日前」が返されるか検証
        // 【期待される動作】: 日付差分N日の場合「N日前」を返す
        // 🔵 信頼性: test-patterns.mdのサンプル実装より

        // 【テスト前準備】: 現在日時を固定
        vi.useFakeTimers();
        vi.setSystemTime(new Date('2025-01-15T12:00:00.000Z'));

        // 【テストデータ準備】: 5日前の日付
        const fiveDaysAgo = new Date('2025-01-10T12:00:00.000Z');

        // 【実際の処理実行】: getRelativeTime関数を呼び出し
        const result = getRelativeTime(fiveDaysAgo);

        // 【結果検証】: 「5日前」が返されることを確認
        // 🔵 信頼性: test-patterns.mdより
        expect(result).toBe('5日前'); // 【確認内容】: 5日前は「5日前」と表示

        // 【テスト後処理】: タイマーを元に戻す
        vi.useRealTimers();
      });

      // TC-R-004: 大きな日数差（30日前）の表示 🟡
      it('TC-R-004: 大きな日数差（30日前）を正しく表示する', () => {
        // 【テスト目的】: 大きな日数差（30日前）が正しく表示されることを確認
        // 【テスト内容】: 30日前の日付を渡し、「30日前」が返されるか検証
        // 🟡 信頼性: 要件定義書から妥当な推測

        // 【テスト前準備】: 現在日時を固定
        vi.useFakeTimers();
        vi.setSystemTime(new Date('2025-01-31T12:00:00.000Z'));

        // 【テストデータ準備】: 30日前の日付
        const thirtyDaysAgo = new Date('2025-01-01T12:00:00.000Z');

        // 【実際の処理実行】: getRelativeTime関数を呼び出し
        const result = getRelativeTime(thirtyDaysAgo);

        // 【結果検証】: 「30日前」が返されることを確認
        // 🟡 信頼性: 要件定義書より推測
        expect(result).toBe('30日前'); // 【確認内容】: 30日前の正しい表示

        // 【テスト後処理】: タイマーを元に戻す
        vi.useRealTimers();
      });
    });

    // ========================================
    // 境界値テストケース
    // ========================================

    describe('境界値テストケース', () => {
      // TC-R-201: 日付境界（23:59 → 0:00）での計算 🔵
      it('TC-R-201: 日付境界（23:59 → 0:00）で正しく計算する', () => {
        // 【テスト目的】: 日付境界（23:59 → 0:00）で正しく計算されることを確認
        // 【テスト内容】: 日付変更直後のタイミングで「1日前」と表示されるか検証
        // 【期待される動作】: 日付単位で差分を計算し、正しく「1日前」を返す
        // 🔵 信頼性: 要件定義書セクション4.2より

        // 【テスト前準備】: 現在日時をJST 0:00:01に固定
        // 【タイムゾーン考慮】: Asia/Tokyoで計算されるため、JSTで日付境界を設定
        // JST 2025-01-15 00:00:01 = UTC 2025-01-14 15:00:01
        vi.useFakeTimers();
        vi.setSystemTime(new Date('2025-01-14T15:00:01.000Z')); // JST 0:00:01

        // 【テストデータ準備】: 前日（JST）の23:59:59
        // JST 2025-01-14 23:59:59 = UTC 2025-01-14 14:59:59
        // 【境界条件】: JSTで日付が1日異なる
        const yesterday = new Date('2025-01-14T14:59:59.000Z');

        // 【実際の処理実行】: getRelativeTime関数を呼び出し
        const result = getRelativeTime(yesterday);

        // 【結果検証】: 「1日前」が返されることを確認
        // 【確認内容】: 時刻ではなく日付単位で計算されること（Asia/Tokyo基準）
        // 🔵 信頼性: 要件定義書より
        expect(result).toBe('1日前'); // 【確認内容】: 日付境界での正しい計算

        // 【テスト後処理】: タイマーを元に戻す
        vi.useRealTimers();
      });

      // TC-R-202: 同日の異なる時刻で「今日」を返す 🔵
      it('TC-R-202: 同日の異なる時刻で「今日」を返す', () => {
        // 【テスト目的】: 同日の異なる時刻でも「今日」と表示されることを確認
        // 【テスト内容】: 時刻が異なる同日の日付を渡し、「今日」が返されるか検証
        // 🔵 信頼性: note.mdの「日付境界の考慮」より

        // 【テスト前準備】: 現在日時を昼に固定
        vi.useFakeTimers();
        vi.setSystemTime(new Date('2025-01-15T12:00:00.000Z')); // 昼12時

        // 【テストデータ準備】: 同日の深夜0時
        // 【境界条件】: 同日だが時刻が12時間異なる
        const sameDay = new Date('2025-01-15T00:00:00.000Z');

        // 【実際の処理実行】: getRelativeTime関数を呼び出し
        const result = getRelativeTime(sameDay);

        // 【結果検証】: 「今日」が返されることを確認
        // 🔵 信頼性: note.mdより
        expect(result).toBe('今日'); // 【確認内容】: 同日の時刻差でも「今日」

        // 【テスト後処理】: タイマーを元に戻す
        vi.useRealTimers();
      });

      // TC-R-203: 年をまたぐ相対日付計算 🟡
      it('TC-R-203: 年をまたぐ相対日付計算を正しく行う', () => {
        // 【テスト目的】: 年をまたぐ相対日付計算が正しく行われることを確認
        // 【テスト内容】: 年をまたぐ日付差分を渡し、正しい日数が返されるか検証
        // 🟡 信頼性: 要件定義書から妥当な推測

        // 【テスト前準備】: 現在日時を2026年1月2日に固定
        vi.useFakeTimers();
        vi.setSystemTime(new Date('2026-01-02T12:00:00.000Z'));

        // 【テストデータ準備】: 2025年12月31日
        // 【境界条件】: 年をまたぐ計算
        const lastYear = new Date('2025-12-31T12:00:00.000Z');

        // 【実際の処理実行】: getRelativeTime関数を呼び出し
        const result = getRelativeTime(lastYear);

        // 【結果検証】: 「2日前」が返されることを確認
        // 🟡 信頼性: 要件定義書より推測
        expect(result).toBe('2日前'); // 【確認内容】: 年をまたぐ日付計算

        // 【テスト後処理】: タイマーを元に戻す
        vi.useRealTimers();
      });
    });
  });
});
