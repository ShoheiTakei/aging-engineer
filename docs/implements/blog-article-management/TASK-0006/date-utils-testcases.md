# TASK-0006: 日付フォーマットユーティリティ - TDDテストケース定義書

**作成日**: 2026-01-01
**タスクID**: TASK-0006
**機能名**: 日付フォーマットユーティリティの実装
**関連要件**: REQ-001, REQ-102, REQ-112
**テストファイル**: `src/utils/date.test.ts`

---

## 1. テストケース概要

### 1.1 テスト対象関数

| 関数名 | 説明 | 信頼性 |
|--------|------|--------|
| `formatDate(date: Date): string` | Dateオブジェクトを日本語フォーマットに変換 | 🔵 |
| `getRelativeTime(date: Date): string` | 相対日付表示（今日、1日前など）を返す | 🔵 |

### 1.2 開発言語・フレームワーク

- **プログラミング言語**: TypeScript 5.7+
  - **言語選択の理由**: プロジェクト全体でTypeScript strict modeを採用しているため
  - **テストに適した機能**: 型安全性、IDE補完、リファクタリング支援
- **テストフレームワーク**: Vitest 2.1.8
  - **フレームワーク選択の理由**: Astroプロジェクトで推奨、Viteとの統合が良好
  - **テスト実行環境**: happy-dom（DOM環境シミュレーション）
- 🔵 この内容は `vitest.config.ts`、`package.json` から確認

### 1.3 参照した要件定義・設計文書

- **要件定義書**: `docs/implements/blog-article-management/TASK-0006/date-utils-requirements.md`
- **タスクノート**: `docs/implements/blog-article-management/TASK-0006/note.md`
- **テストパターン**: `docs/design/frontend-test-infra/test-patterns.md`
- **参照した機能概要**: セクション1.1「何をする機能か」
- **参照した入力・出力仕様**: セクション2「入力・出力の仕様」
- **参照した制約条件**: セクション3「制約条件」
- **参照した使用例**: セクション4「想定される使用例」

---

## 2. formatDate() テストケース

### 2.1 正常系テストケース

#### TC-D-001: 日本語フォーマットでの日付表示 🔵

- **テスト名**: 日本語フォーマットでの日付表示
  - **何をテストするか**: `formatDate()`が`Date`オブジェクトを正しい日本語フォーマットに変換するか
  - **期待される動作**: `Intl.DateTimeFormat`を使用して「年月日」形式で出力
- **入力値**: `new Date('2025-01-15T10:30:00Z')`
  - **入力データの意味**: 標準的な日付、1月（1桁月）のテスト
- **期待される結果**: `"2025年1月15日"`
  - **期待結果の理由**: `Intl.DateTimeFormat('ja-JP')`のデフォルト出力形式
- **テストの目的**: 基本的な日付フォーマット機能の確認
  - **確認ポイント**: 年・月・日が正しい順序で表示されること
- 🔵 このテストケースは `test-patterns.md` から確認

```typescript
// 【テスト目的】: formatDate()が日本語フォーマットで正しく日付を出力することを確認
// 【テスト内容】: 標準的なDateオブジェクトを渡し、「YYYY年M月D日」形式で返されるか検証
// 【期待される動作】: Intl.DateTimeFormatを使用して日本語ロケールで正しくフォーマット
// 🔵 信頼性: test-patterns.mdのサンプル実装より

it('TC-D-001: 日本語フォーマットで日付を表示する', () => {
  // 【テストデータ準備】: 標準的な日付（2025年1月15日）を用意
  // 【前提条件確認】: Dateオブジェクトが有効であること
  const date = new Date('2025-01-15T10:30:00Z');

  // 【実際の処理実行】: formatDate関数を呼び出し
  // 【処理内容】: DateオブジェクトをIntl.DateTimeFormatで日本語フォーマットに変換
  const result = formatDate(date);

  // 【結果検証】: 日本語フォーマットで出力されることを確認
  // 【期待値確認】: 「2025年1月15日」形式で返されること
  // 【品質保証】: 日付表示の基本機能が正しく動作すること
  // 🔵 信頼性: test-patterns.mdより
  expect(result).toBe('2025年1月15日');
});
```

#### TC-D-002: 2桁月（12月）の表示 🔵

- **テスト名**: 2桁月の日付表示
  - **何をテストするか**: 12月のような2桁月が正しくフォーマットされるか
  - **期待される動作**: 12月が「12月」として表示される
- **入力値**: `new Date('2025-12-25')`
  - **入力データの意味**: 12月（2桁月）、クリスマス日
- **期待される結果**: `"2025年12月25日"`
  - **期待結果の理由**: 2桁月も正しく表示されること
- **テストの目的**: 月の桁数による表示差異がないことの確認
  - **確認ポイント**: 月が1桁・2桁に関わらず正しく表示されること
- 🔵 このテストケースは要件定義書セクション2.1より導出

```typescript
// 【テスト目的】: 2桁月（12月）が正しくフォーマットされることを確認
// 【テスト内容】: 12月の日付を渡し、「12月」と正しく表示されるか検証
// 【期待される動作】: 月の桁数に関わらず正しくフォーマット
// 🔵 信頼性: 要件定義書セクション2.1より

it('TC-D-002: 2桁月（12月）を正しく表示する', () => {
  // 【テストデータ準備】: 12月の日付を用意
  const date = new Date('2025-12-25');

  // 【実際の処理実行】: formatDate関数を呼び出し
  const result = formatDate(date);

  // 【結果検証】: 12月が正しく表示されることを確認
  // 🔵 信頼性: 要件定義書より
  expect(result).toBe('2025年12月25日');
});
```

#### TC-D-003: 日本語ロケールでの月表記 🔵

- **テスト名**: 日本語ロケールでの月表記
  - **何をテストするか**: 月が漢字表記（「月」）で表示されるか
  - **期待される動作**: `ja-JP`ロケールにより「N月」形式で表示
- **入力値**: `new Date('2025-06-01')`
  - **入力データの意味**: 6月（月の途中の値）
- **期待される結果**: `"2025年6月1日"`
  - **期待結果の理由**: 日本語ロケールでは「N月」形式
- **テストの目的**: 日本語ロケール設定の確認
  - **確認ポイント**: 英語表記（June等）ではなく日本語表記になること
- 🔵 このテストケースは `test-patterns.md` から確認

```typescript
// 【テスト目的】: 日本語ロケールで月が漢字表記になることを確認
// 【テスト内容】: 6月の日付を渡し、「6月」と表示されるか検証
// 【期待される動作】: ja-JPロケールにより日本語表記
// 🔵 信頼性: test-patterns.mdより

it('TC-D-003: 日本語ロケールで月が正しく表記される', () => {
  // 【テストデータ準備】: 6月の日付を用意
  const date = new Date('2025-06-01');

  // 【実際の処理実行】: formatDate関数を呼び出し
  const result = formatDate(date);

  // 【結果検証】: 日本語形式で表示されることを確認
  // 【確認内容】: 「June」ではなく「6月」と表示されること
  // 🔵 信頼性: test-patterns.mdより
  expect(result).toBe('2025年6月1日');
});
```

### 2.2 異常系テストケース

#### TC-D-101: 無効な日付でエラーをスロー 🔵

- **テスト名**: 無効な日付でエラーをスロー
  - **エラーケースの概要**: `Invalid Date`オブジェクトが渡された場合
  - **エラー処理の重要性**: 不正な入力で予期しない動作を防ぐ
- **入力値**: `new Date('invalid')`
  - **不正な理由**: 解析不可能な文字列で生成されたDateオブジェクト
  - **実際の発生シナリオ**: Content Collectionsでのデータ取得エラー時
- **期待される結果**: `Error: Invalid date` をスロー
  - **エラーメッセージの内容**: 開発者が問題を特定しやすいメッセージ
  - **システムの安全性**: エラーをキャッチして適切に処理可能
- **テストの目的**: エラーハンドリングの確認
  - **品質保証の観点**: 不正入力時の堅牢性を保証
- 🔵 このテストケースは `test-patterns.md` から確認

```typescript
// 【テスト目的】: 無効な日付入力時に適切なエラーがスローされることを確認
// 【テスト内容】: Invalid Dateオブジェクトを渡し、エラーがスローされるか検証
// 【期待される動作】: Error: Invalid dateがスローされる
// 🔵 信頼性: test-patterns.mdのサンプル実装より

it('TC-D-101: 無効な日付でエラーをスローする', () => {
  // 【テストデータ準備】: 無効な日付文字列から生成されたDateオブジェクト
  // 【前提条件確認】: isNaN(date.getTime())がtrueになること
  const invalidDate = new Date('invalid');

  // 【実際の処理実行】: formatDate関数を呼び出し
  // 【処理内容】: 無効な日付に対してエラーをスローする処理

  // 【結果検証】: エラーがスローされることを確認
  // 【期待値確認】: 'Invalid date'メッセージを含むエラー
  // 【品質保証】: 不正入力時にシステムが安全にエラーを報告すること
  // 🔵 信頼性: test-patterns.mdより
  expect(() => formatDate(invalidDate)).toThrow('Invalid date');
});
```

#### TC-D-102: NaN Dateでエラーをスロー 🔵

- **テスト名**: NaN Dateでエラーをスロー
  - **エラーケースの概要**: `new Date(NaN)`で生成されたDateオブジェクト
  - **エラー処理の重要性**: 計算エラーによる不正なDateを検出
- **入力値**: `new Date(NaN)`
  - **不正な理由**: NaNから生成されたDateオブジェクト
  - **実際の発生シナリオ**: 日付計算エラー時
- **期待される結果**: `Error: Invalid date` をスロー
  - **エラーメッセージの内容**: 無効な日付と同じエラーメッセージ
  - **システムの安全性**: 一貫したエラーハンドリング
- **テストの目的**: NaN由来の無効な日付の検出
  - **品質保証の観点**: さまざまな無効な日付パターンへの対応
- 🔵 このテストケースは `note.md` の「無効な日付の処理」より導出

```typescript
// 【テスト目的】: NaNから生成されたDateでエラーがスローされることを確認
// 【テスト内容】: new Date(NaN)を渡し、エラーがスローされるか検証
// 【期待される動作】: Error: Invalid dateがスローされる
// 🔵 信頼性: note.mdの「無効な日付の処理」より

it('TC-D-102: NaN Dateでエラーをスローする', () => {
  // 【テストデータ準備】: NaNから生成されたDateオブジェクト
  const nanDate = new Date(NaN);

  // 【結果検証】: エラーがスローされることを確認
  // 🔵 信頼性: note.mdより
  expect(() => formatDate(nanDate)).toThrow('Invalid date');
});
```

### 2.3 境界値テストケース

#### TC-D-201: 年末（12月31日）の日付表示 🔵

- **テスト名**: 年末（12月31日）の日付表示
  - **境界値の意味**: 年の最終日、年末年始境界
  - **境界値での動作保証**: 年末でも正しく表示されること
- **入力値**: `new Date('2025-12-31')`
  - **境界値選択の根拠**: 年の最終日は境界値として重要
  - **実際の使用場面**: 年末の記事投稿
- **期待される結果**: `"2025年12月31日"`
  - **境界での正確性**: 年と日が正しく表示されること
  - **一貫した動作**: 他の日付と同様にフォーマットされること
- **テストの目的**: 年末境界での動作確認
  - **堅牢性の確認**: 境界日付でも正しく処理されること
- 🔵 このテストケースは要件定義書セクション4.2「エッジケース」より導出

```typescript
// 【テスト目的】: 年末（12月31日）が正しくフォーマットされることを確認
// 【テスト内容】: 年の最終日を渡し、正しく表示されるか検証
// 【期待される動作】: 境界日付でも正常にフォーマット
// 🔵 信頼性: 要件定義書セクション4.2より

it('TC-D-201: 年末（12月31日）を正しく表示する', () => {
  // 【テストデータ準備】: 年末の日付（2025年12月31日）
  // 【境界条件】: 年の最終日
  const date = new Date('2025-12-31');

  // 【実際の処理実行】: formatDate関数を呼び出し
  const result = formatDate(date);

  // 【結果検証】: 年末日付が正しく表示されることを確認
  // 🔵 信頼性: 要件定義書より
  expect(result).toBe('2025年12月31日');
});
```

#### TC-D-202: 年始（1月1日）の日付表示 🔵

- **テスト名**: 年始（1月1日）の日付表示
  - **境界値の意味**: 年の最初の日、年末年始境界
  - **境界値での動作保証**: 年始でも正しく表示されること
- **入力値**: `new Date('2026-01-01')`
  - **境界値選択の根拠**: 年の最初の日は境界値として重要
  - **実際の使用場面**: 新年の記事投稿
- **期待される結果**: `"2026年1月1日"`
  - **境界での正確性**: 年と月と日が正しく表示されること
  - **一貫した動作**: 他の日付と同様にフォーマットされること
- **テストの目的**: 年始境界での動作確認
  - **堅牢性の確認**: 境界日付でも正しく処理されること
- 🔵 このテストケースは要件定義書セクション4.2「エッジケース」より導出

```typescript
// 【テスト目的】: 年始（1月1日）が正しくフォーマットされることを確認
// 【テスト内容】: 年の最初の日を渡し、正しく表示されるか検証
// 【期待される動作】: 境界日付でも正常にフォーマット
// 🔵 信頼性: 要件定義書セクション4.2より

it('TC-D-202: 年始（1月1日）を正しく表示する', () => {
  // 【テストデータ準備】: 年始の日付（2026年1月1日）
  // 【境界条件】: 年の最初の日
  const date = new Date('2026-01-01');

  // 【実際の処理実行】: formatDate関数を呼び出し
  const result = formatDate(date);

  // 【結果検証】: 年始日付が正しく表示されることを確認
  // 🔵 信頼性: 要件定義書より
  expect(result).toBe('2026年1月1日');
});
```

#### TC-D-203: 閏年（2月29日）の日付表示 🔵

- **テスト名**: 閏年（2月29日）の日付表示
  - **境界値の意味**: 閏年にのみ存在する日付
  - **境界値での動作保証**: 特殊な日付でも正しく表示されること
- **入力値**: `new Date('2024-02-29')`
  - **境界値選択の根拠**: 2024年は閏年、2月29日が存在
  - **実際の使用場面**: 閏年の記事投稿
- **期待される結果**: `"2024年2月29日"`
  - **境界での正確性**: 閏年の2月29日が正しく表示されること
  - **一貫した動作**: 他の日付と同様にフォーマットされること
- **テストの目的**: 閏年境界での動作確認
  - **堅牢性の確認**: 特殊な日付でも正しく処理されること
- 🔵 このテストケースは `note.md` の「境界値: 閏年」より導出

```typescript
// 【テスト目的】: 閏年の2月29日が正しくフォーマットされることを確認
// 【テスト内容】: 閏年にのみ存在する日付を渡し、正しく表示されるか検証
// 【期待される動作】: 特殊な日付でも正常にフォーマット
// 🔵 信頼性: note.mdの「境界値: 閏年」より

it('TC-D-203: 閏年（2月29日）を正しく表示する', () => {
  // 【テストデータ準備】: 閏年の2月29日（2024年）
  // 【境界条件】: 閏年にのみ存在する日付
  const date = new Date('2024-02-29');

  // 【実際の処理実行】: formatDate関数を呼び出し
  const result = formatDate(date);

  // 【結果検証】: 閏年日付が正しく表示されることを確認
  // 🔵 信頼性: note.mdより
  expect(result).toBe('2024年2月29日');
});
```

#### TC-D-204: 月初（1日）の日付表示 🔵

- **テスト名**: 月初（1日）の日付表示
  - **境界値の意味**: 月の最初の日
  - **境界値での動作保証**: 月初でも正しく表示されること
- **入力値**: `new Date('2025-03-01')`
  - **境界値選択の根拠**: 月の最初の日は境界値
  - **実際の使用場面**: 月初めの記事投稿
- **期待される結果**: `"2025年3月1日"`
  - **境界での正確性**: 日が「1日」と正しく表示されること
- **テストの目的**: 月初境界での動作確認
- 🔵 このテストケースは要件定義書より妥当な推測

```typescript
// 【テスト目的】: 月初（1日）が正しくフォーマットされることを確認
// 【テスト内容】: 月の最初の日を渡し、正しく表示されるか検証
// 🔵 信頼性: 要件定義書より妥当な推測

it('TC-D-204: 月初（1日）を正しく表示する', () => {
  // 【テストデータ準備】: 月初の日付（3月1日）
  const date = new Date('2025-03-01');

  // 【実際の処理実行】: formatDate関数を呼び出し
  const result = formatDate(date);

  // 【結果検証】: 月初日付が正しく表示されることを確認
  // 🔵 信頼性: 要件定義書より
  expect(result).toBe('2025年3月1日');
});
```

---

## 3. getRelativeTime() テストケース

### 3.1 正常系テストケース

#### TC-R-001: 今日の日付で「今日」を返す 🔵

- **テスト名**: 今日の日付で「今日」を返す
  - **何をテストするか**: 当日の日付が「今日」と表示されるか
  - **期待される動作**: 日付差分が0日の場合「今日」を返す
- **入力値**: 現在日時と同じ日付のDateオブジェクト
  - **入力データの意味**: テスト実行時の日付
- **期待される結果**: `"今日"`
  - **期待結果の理由**: 相対日付表示の基本ケース
- **テストの目的**: 「今日」の表示確認
  - **確認ポイント**: 時刻に関係なく同日は「今日」と表示
- 🔵 このテストケースは `test-patterns.md` から確認

```typescript
// 【テスト目的】: 今日の日付が「今日」と表示されることを確認
// 【テスト内容】: 現在日時を渡し、「今日」が返されるか検証
// 【期待される動作】: 日付差分0日の場合「今日」を返す
// 🔵 信頼性: test-patterns.mdのサンプル実装より

it('TC-R-001: 今日の日付で「今日」を返す', () => {
  // 【テスト前準備】: 現在日時を固定
  vi.useFakeTimers();
  vi.setSystemTime(new Date('2025-01-15T12:00:00.000Z'));

  // 【テストデータ準備】: 今日の日付
  const today = new Date('2025-01-15T09:00:00.000Z');

  // 【実際の処理実行】: getRelativeTime関数を呼び出し
  const result = getRelativeTime(today);

  // 【結果検証】: 「今日」が返されることを確認
  // 🔵 信頼性: test-patterns.mdより
  expect(result).toBe('今日');

  // 【テスト後処理】: タイマーを元に戻す
  vi.useRealTimers();
});
```

#### TC-R-002: 1日前の日付で「1日前」を返す 🔵

- **テスト名**: 1日前の日付で「1日前」を返す
  - **何をテストするか**: 1日前の日付が「1日前」と表示されるか
  - **期待される動作**: 日付差分が1日の場合「1日前」を返す
- **入力値**: 現在日時の1日前のDateオブジェクト
  - **入力データの意味**: 昨日の日付
- **期待される結果**: `"1日前"`
  - **期待結果の理由**: 相対日付表示で1日前を表す
- **テストの目的**: 「1日前」の表示確認
  - **確認ポイント**: 日付境界を正しく計算
- 🔵 このテストケースは `test-patterns.md` から確認

```typescript
// 【テスト目的】: 1日前の日付が「1日前」と表示されることを確認
// 【テスト内容】: 昨日の日付を渡し、「1日前」が返されるか検証
// 【期待される動作】: 日付差分1日の場合「1日前」を返す
// 🔵 信頼性: test-patterns.mdのサンプル実装より

it('TC-R-002: 1日前の日付で「1日前」を返す', () => {
  // 【テスト前準備】: 現在日時を固定
  vi.useFakeTimers();
  vi.setSystemTime(new Date('2025-01-15T12:00:00.000Z'));

  // 【テストデータ準備】: 1日前の日付
  const yesterday = new Date('2025-01-14T12:00:00.000Z');

  // 【実際の処理実行】: getRelativeTime関数を呼び出し
  const result = getRelativeTime(yesterday);

  // 【結果検証】: 「1日前」が返されることを確認
  // 🔵 信頼性: test-patterns.mdより
  expect(result).toBe('1日前');

  // 【テスト後処理】: タイマーを元に戻す
  vi.useRealTimers();
});
```

#### TC-R-003: N日前の日付で「N日前」を返す 🔵

- **テスト名**: N日前の日付で「N日前」を返す
  - **何をテストするか**: 複数日前の日付が「N日前」と表示されるか
  - **期待される動作**: 日付差分がN日の場合「N日前」を返す
- **入力値**: 現在日時の5日前のDateオブジェクト
  - **入力データの意味**: 5日前の日付（複数日前の代表例）
- **期待される結果**: `"5日前"`
  - **期待結果の理由**: 相対日付表示でN日前を表す
- **テストの目的**: 「N日前」の表示確認
  - **確認ポイント**: 複数日前も正しく計算
- 🔵 このテストケースは `test-patterns.md` から確認

```typescript
// 【テスト目的】: N日前の日付が「N日前」と表示されることを確認
// 【テスト内容】: 5日前の日付を渡し、「5日前」が返されるか検証
// 【期待される動作】: 日付差分N日の場合「N日前」を返す
// 🔵 信頼性: test-patterns.mdのサンプル実装より

it('TC-R-003: N日前の日付で「N日前」を返す', () => {
  // 【テスト前準備】: 現在日時を固定
  vi.useFakeTimers();
  vi.setSystemTime(new Date('2025-01-15T12:00:00.000Z'));

  // 【テストデータ準備】: 5日前の日付
  const fiveDaysAgo = new Date('2025-01-10T12:00:00.000Z');

  // 【実際の処理実行】: getRelativeTime関数を呼び出し
  const result = getRelativeTime(fiveDaysAgo);

  // 【結果検証】: 「5日前」が返されることを確認
  // 🔵 信頼性: test-patterns.mdより
  expect(result).toBe('5日前');

  // 【テスト後処理】: タイマーを元に戻す
  vi.useRealTimers();
});
```

#### TC-R-004: 大きな日数差（30日前）の表示 🟡

- **テスト名**: 大きな日数差（30日前）の表示
  - **何をテストするか**: 1ヶ月程度前の日付が正しく表示されるか
  - **期待される動作**: 「30日前」と表示される
- **入力値**: 現在日時の30日前のDateオブジェクト
  - **入力データの意味**: 約1ヶ月前の日付
- **期待される結果**: `"30日前"`
  - **期待結果の理由**: 日数ベースの相対表示
- **テストの目的**: 大きな日数差での動作確認
  - **確認ポイント**: 日数が大きくても正しく計算
- 🟡 このテストケースは要件定義書から妥当な推測

```typescript
// 【テスト目的】: 大きな日数差（30日前）が正しく表示されることを確認
// 【テスト内容】: 30日前の日付を渡し、「30日前」が返されるか検証
// 🟡 信頼性: 要件定義書から妥当な推測

it('TC-R-004: 大きな日数差（30日前）を正しく表示する', () => {
  // 【テスト前準備】: 現在日時を固定
  vi.useFakeTimers();
  vi.setSystemTime(new Date('2025-01-31T12:00:00.000Z'));

  // 【テストデータ準備】: 30日前の日付
  const thirtyDaysAgo = new Date('2025-01-01T12:00:00.000Z');

  // 【実際の処理実行】: getRelativeTime関数を呼び出し
  const result = getRelativeTime(thirtyDaysAgo);

  // 【結果検証】: 「30日前」が返されることを確認
  // 🟡 信頼性: 要件定義書より推測
  expect(result).toBe('30日前');

  // 【テスト後処理】: タイマーを元に戻す
  vi.useRealTimers();
});
```

### 3.2 境界値テストケース

#### TC-R-201: 日付境界（23:59 → 0:00）での計算 🔵

- **テスト名**: 日付境界（23:59 → 0:00）での計算
  - **境界値の意味**: 日付変更直後のタイミング
  - **境界値での動作保証**: 日付境界を正しく判定
- **入力値**: 現在日時が0:00:01、対象日付が前日23:59:59
  - **境界値選択の根拠**: 日付変更の境界タイミング
  - **実際の使用場面**: 日付変更直後の記事表示
- **期待される結果**: `"1日前"`
  - **境界での正確性**: 時刻ではなく日付単位で計算
  - **一貫した動作**: 日付が異なれば1日前と判定
- **テストの目的**: 日付境界での正確な計算
  - **堅牢性の確認**: 境界タイミングでも正しく動作
- 🔵 このテストケースは要件定義書セクション4.2「日付境界」より導出

```typescript
// 【テスト目的】: 日付境界（23:59 → 0:00）で正しく計算されることを確認
// 【テスト内容】: 日付変更直後のタイミングで「1日前」と表示されるか検証
// 【期待される動作】: 日付単位で差分を計算し、正しく「1日前」を返す
// 🔵 信頼性: 要件定義書セクション4.2より

it('TC-R-201: 日付境界（23:59 → 0:00）で正しく計算する', () => {
  // 【テスト前準備】: 現在日時を日付変更直後に固定
  vi.useFakeTimers();
  vi.setSystemTime(new Date('2025-01-15T00:00:01.000Z')); // UTC 0:00:01

  // 【テストデータ準備】: 前日の23:59:59
  // 【境界条件】: 時刻は異なるが日付は1日異なる
  const yesterday = new Date('2025-01-14T23:59:59.000Z');

  // 【実際の処理実行】: getRelativeTime関数を呼び出し
  const result = getRelativeTime(yesterday);

  // 【結果検証】: 「1日前」が返されることを確認
  // 【確認内容】: 時刻ではなく日付単位で計算されること
  // 🔵 信頼性: 要件定義書より
  expect(result).toBe('1日前');

  // 【テスト後処理】: タイマーを元に戻す
  vi.useRealTimers();
});
```

#### TC-R-202: 同日の異なる時刻で「今日」を返す 🔵

- **テスト名**: 同日の異なる時刻で「今日」を返す
  - **境界値の意味**: 同じ日付の異なる時刻
  - **境界値での動作保証**: 時刻に関係なく同日は「今日」
- **入力値**: 現在日時が昼、対象日付が同日深夜
  - **境界値選択の根拠**: 同日内の時刻差
  - **実際の使用場面**: 同日に複数回閲覧
- **期待される結果**: `"今日"`
  - **境界での正確性**: 同日であれば必ず「今日」
- **テストの目的**: 同日判定の正確性確認
- 🔵 このテストケースは `note.md` の「日付境界の考慮」より導出

```typescript
// 【テスト目的】: 同日の異なる時刻でも「今日」と表示されることを確認
// 【テスト内容】: 時刻が異なる同日の日付を渡し、「今日」が返されるか検証
// 🔵 信頼性: note.mdの「日付境界の考慮」より

it('TC-R-202: 同日の異なる時刻で「今日」を返す', () => {
  // 【テスト前準備】: 現在日時を昼に固定
  vi.useFakeTimers();
  vi.setSystemTime(new Date('2025-01-15T12:00:00.000Z')); // 昼12時

  // 【テストデータ準備】: 同日の深夜0時
  // 【境界条件】: 同日だが時刻が12時間異なる
  const sameDay = new Date('2025-01-15T00:00:00.000Z');

  // 【実際の処理実行】: getRelativeTime関数を呼び出し
  const result = getRelativeTime(sameDay);

  // 【結果検証】: 「今日」が返されることを確認
  // 🔵 信頼性: note.mdより
  expect(result).toBe('今日');

  // 【テスト後処理】: タイマーを元に戻す
  vi.useRealTimers();
});
```

#### TC-R-203: 年をまたぐ相対日付計算 🟡

- **テスト名**: 年をまたぐ相対日付計算
  - **境界値の意味**: 年末から年始への日付差分
  - **境界値での動作保証**: 年をまたいでも正しく計算
- **入力値**: 現在日時が2026年1月2日、対象日付が2025年12月31日
  - **境界値選択の根拠**: 年をまたぐ計算
  - **実際の使用場面**: 年末年始の記事表示
- **期待される結果**: `"2日前"`
  - **境界での正確性**: 年をまたいでも日数差分が正しい
- **テストの目的**: 年をまたぐ計算の正確性確認
- 🟡 このテストケースは要件定義書から妥当な推測

```typescript
// 【テスト目的】: 年をまたぐ相対日付計算が正しく行われることを確認
// 【テスト内容】: 年をまたぐ日付差分を渡し、正しい日数が返されるか検証
// 🟡 信頼性: 要件定義書から妥当な推測

it('TC-R-203: 年をまたぐ相対日付計算を正しく行う', () => {
  // 【テスト前準備】: 現在日時を2026年1月2日に固定
  vi.useFakeTimers();
  vi.setSystemTime(new Date('2026-01-02T12:00:00.000Z'));

  // 【テストデータ準備】: 2025年12月31日
  // 【境界条件】: 年をまたぐ計算
  const lastYear = new Date('2025-12-31T12:00:00.000Z');

  // 【実際の処理実行】: getRelativeTime関数を呼び出し
  const result = getRelativeTime(lastYear);

  // 【結果検証】: 「2日前」が返されることを確認
  // 🟡 信頼性: 要件定義書より推測
  expect(result).toBe('2日前');

  // 【テスト後処理】: タイマーを元に戻す
  vi.useRealTimers();
});
```

---

## 4. セットアップ・クリーンアップ

```typescript
// 【テストスイートセットアップ】
// src/utils/date.test.ts

import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest';
import { formatDate, getRelativeTime } from './date';

describe('date utilities', () => {
  // ========================================
  // セットアップ・クリーンアップ
  // ========================================

  beforeEach(() => {
    // 【テスト前準備】: Fake Timersを有効化（getRelativeTime用）
    // 【環境初期化】: テストごとに現在日時を固定可能にする
  });

  afterEach(() => {
    // 【テスト後処理】: Fake Timersを元に戻す
    // 【状態復元】: 次のテストに影響しないよう実時間に復元
    vi.useRealTimers();
  });

  // 以下にテストケースを記述
});
```

---

## 5. 要件定義との対応関係

### 5.1 参照した要件定義

| 要件ID | 要件内容 | 対応テストケース |
|--------|---------|-----------------|
| REQ-001 | frontmatterでpubDate, updatedDateを管理 | TC-D-001〜TC-D-204 |
| REQ-102 | 記事一覧で公開日を表示 | TC-D-001, TC-D-002, TC-D-003 |
| REQ-112 | 記事詳細で公開日・更新日を表示 | TC-D-001, TC-D-002, TC-D-003 |
| NFR-001 | Lighthouse 90+点維持 | 外部ライブラリ不使用の確認（実装時） |

### 5.2 参照した設計文書

| 文書 | 該当セクション | 対応テストケース |
|------|--------------|-----------------|
| `test-patterns.md` | 1.1 日付フォーマット関数 | TC-D-001, TC-D-101, TC-R-001〜003 |
| `note.md` | 5. 注意事項 | TC-D-102, TC-R-201, TC-R-202 |
| `date-utils-requirements.md` | 4.2 エッジケース | TC-D-201〜204, TC-R-203 |

---

## 6. 信頼性レベルサマリー

| レベル | 件数 | 割合 | 説明 |
|--------|------|------|------|
| 🔵 青信号 | 14 | 87.5% | test-patterns.md・要件定義書から確実に導出 |
| 🟡 黄信号 | 2 | 12.5% | 要件定義書から妥当な推測 |
| 🔴 赤信号 | 0 | 0% | 推測なし |

### テストケース一覧

| テストID | テスト名 | 信頼性 |
|----------|---------|--------|
| TC-D-001 | 日本語フォーマットでの日付表示 | 🔵 |
| TC-D-002 | 2桁月（12月）の表示 | 🔵 |
| TC-D-003 | 日本語ロケールでの月表記 | 🔵 |
| TC-D-101 | 無効な日付でエラーをスロー | 🔵 |
| TC-D-102 | NaN Dateでエラーをスロー | 🔵 |
| TC-D-201 | 年末（12月31日）の日付表示 | 🔵 |
| TC-D-202 | 年始（1月1日）の日付表示 | 🔵 |
| TC-D-203 | 閏年（2月29日）の日付表示 | 🔵 |
| TC-D-204 | 月初（1日）の日付表示 | 🔵 |
| TC-R-001 | 今日の日付で「今日」を返す | 🔵 |
| TC-R-002 | 1日前の日付で「1日前」を返す | 🔵 |
| TC-R-003 | N日前の日付で「N日前」を返す | 🔵 |
| TC-R-004 | 大きな日数差（30日前）の表示 | 🟡 |
| TC-R-201 | 日付境界（23:59 → 0:00）での計算 | 🔵 |
| TC-R-202 | 同日の異なる時刻で「今日」を返す | 🔵 |
| TC-R-203 | 年をまたぐ相対日付計算 | 🟡 |

---

## 7. 品質判定結果

### 7.1 品質評価: ✅ 高品質

**評価基準チェック**:

| 基準 | 状態 | 詳細 |
|------|------|------|
| テストケース分類 | ✅ | 正常系・異常系・境界値が網羅されている |
| 期待値定義 | ✅ | 各テストケースの期待値が明確 |
| 技術選択 | ✅ | TypeScript + Vitest が確定 |
| 実装可能性 | ✅ | 現在の技術スタックで実現可能 |
| 信頼性レベル | ✅ | 🔵（青信号）が87.5%で多数 |

### 7.2 テストカバレッジ概要

- **formatDate()**: 正常系3件 + 異常系2件 + 境界値4件 = 9件
- **getRelativeTime()**: 正常系4件 + 境界値3件 = 7件
- **合計**: 16件

### 7.3 改善提案

現時点で大きな改善点はありませんが、以下を検討可能です：

1. **将来日付の処理**: 現在は過去日付のみ対象。将来日付の表示仕様が必要な場合は追加
2. **無効な日付のgetRelativeTime()**: 異常系テストケースの追加を検討

---

**最終更新日**: 2026-01-01
**作成者**: Claude Opus 4.5 (TDD開発エージェント)
